from django.contrib.auth.base_user import AbstractBaseUser
from django.contrib.auth.tokens import PasswordResetTokenGenerator
from django.utils.crypto import constant_time_compare
from django.utils.http import base36_to_int
from django.utils import timezone
from .models import * 


class TokenGeneratorValidator(PasswordResetTokenGenerator):
     
    def _num_to_timestamp(self, num):
        """
        Converts a base36 encoded number to a timestamp.
        """
        try:
            return int(num, 36)
        except ValueError:
            raise ValueError("Invalid base36 encoded timestamp")
        
    def _make_hash_value(self, user, timestamp):
        return (
            str(user.pk) + str(timestamp) + str(user.is_active)
        )
    
    def check_token(self, user, token, duration):
        try:
            get_token_from_database= TokensModel.objects.get(token= token)
            expiration_time= timezone.now() - timezone.timedelta(minutes= int(duration))
            print(f'fdb-{get_token_from_database.timestamp}------{expiration_time}-----{get_token_from_database.timestamp > expiration_time}')
            if get_token_from_database is not None and get_token_from_database.user_id == user.id: #checking if token exist and also if token was generated by the current user
                if get_token_from_database.timestamp > expiration_time: #checking if it still valid
                    return True
                else:
                    get_token_from_database.delete() # deleting token if it has expired
                    return False
            else:
                return False
        except (TypeError, ValueError, OverflowError, TokensModel.DoesNotExist):
            return False
        
 
    
# Create an instance of the custom token generator Validator
TokenGeneratorValidator = TokenGeneratorValidator()
